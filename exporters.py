"""
Zone Configuration Exporters
==============================

Exports zone configurations to Python code and JSON format,
matching the exact structure used in templates.
"""

import json
from typing import Dict, Any


def clean_zone_config(zone_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Clean zone configuration for export, removing internal metadata

    Keeps only keys that are valid in template FIELD_ZONES
    """
    # Core keys that always appear - ensure they're tuples
    y_range = zone_config['y_range']
    x_range = zone_config['x_range']

    clean = {
        'y_range': tuple(y_range) if isinstance(y_range, (list, tuple)) else y_range,
        'x_range': tuple(x_range) if isinstance(x_range, (list, tuple)) else x_range,
    }

    # Format and format-specific keys
    if zone_config.get('format') and zone_config['format'] != 'string':
        clean['format'] = zone_config['format']

        # Date-specific
        if zone_config['format'] == 'date' and zone_config.get('date_format'):
            clean['date_format'] = zone_config['date_format']

        # Height-specific
        if zone_config['format'] == 'height' and zone_config.get('height_format'):
            clean['height_format'] = zone_config['height_format']

        # Weight-specific
        if zone_config['format'] == 'weight' and zone_config.get('weight_format'):
            clean['weight_format'] = zone_config['weight_format']

    # Pattern matching keys
    if zone_config.get('pattern'):
        clean['pattern'] = zone_config['pattern']

    if zone_config.get('cleanup_pattern'):
        clean['cleanup_pattern'] = zone_config['cleanup_pattern']

    if zone_config.get('consensus_extract'):
        clean['consensus_extract'] = zone_config['consensus_extract']
    else:
        # AUTO-ADD consensus_extract for normalized fields
        # These fields use normalizers that extract values from messy text
        field_format = zone_config.get('format')
        if field_format in ['height', 'sex', 'eyes', 'hair', 'weight']:
            clean['consensus_extract'] = r".*"  # Match any text, let normalizer handle extraction

    # Expected labels (fuzzy matching for label detection)
    if zone_config.get('labels'):
        clean['labels'] = zone_config['labels']

    # Clustering keys
    if zone_config.get('cluster_by'):
        clean['cluster_by'] = zone_config['cluster_by']
    if zone_config.get('cluster_select'):
        clean['cluster_select'] = zone_config['cluster_select']
    if zone_config.get('cluster_tolerance'):
        clean['cluster_tolerance'] = zone_config['cluster_tolerance']

    # Tie-breaking strategy for character voting
    if zone_config.get('tie_break_prefer'):
        clean['tie_break_prefer'] = zone_config['tie_break_prefer']

    # Text processing flags
    if zone_config.get('uppercase'):
        clean['uppercase'] = True
    if zone_config.get('validate_alphabetic'):
        clean['validate_alphabetic'] = True
    if zone_config.get('allow_commas') is False:
        clean['allow_commas'] = False
    if zone_config.get('allow_digits') is False:
        clean['allow_digits'] = False

    # Validation flags
    if zone_config.get('strict_validation'):
        clean['strict_validation'] = True
    if zone_config.get('optional'):
        clean['optional'] = True

    return clean


def export_to_json(zones: Dict[str, Dict[str, Any]]) -> str:
    """
    Export zones to JSON format

    Args:
        zones: Dict mapping field names to zone configurations

    Returns:
        JSON string with proper formatting
    """
    clean_zones = {}
    for field_name, zone_config in zones.items():
        clean_zones[field_name] = clean_zone_config(zone_config)

    return json.dumps(clean_zones, indent=2)


def export_to_python(zones: Dict[str, Dict[str, Any]], metadata: Dict[str, Any] = None) -> str:
    """
    Export zones to Python code matching template structure exactly

    Args:
        zones: Dict mapping field names to zone configurations
        metadata: Template metadata (template_name, class_name, version)
                 document_type is auto-set to template_name

    Returns:
        Python code string ready to paste into a template file
    """
    # Use metadata or defaults (simplified to essential fields only)
    if metadata is None:
        metadata = {
            'template_name': 'my_template',
            'class_name': 'MyTemplate',
            'version': '1.0'
        }

    class_name = metadata.get('class_name', 'MyTemplate')
    document_type = metadata.get('document_type', metadata.get('template_name', 'my_template'))
    version = metadata.get('version', '1.0')
    template_name = metadata.get('template_name', 'my_template')

    # Get list of all field names for REQUIRED_FIELDS
    field_names = list(zones.keys())

    lines = [
        '"""',
        f'{document_type} - Field Extraction Template',
        "",
        f'Generated by Interactive Zone Builder',
        f'Version: {version}',
        "",
        f'Extracts fields: {", ".join(field_names)}',
        '"""',
        "",
        "from typing import Any, Dict",
        "from app.field_extraction.hybrid_template import HybridTemplate",
        "",
        "",
        f"class {class_name}(HybridTemplate):",
        f'    """Auto-generated template from Zone Builder"""',
        "",
        f'    document_type = "{template_name}"',
        f'    version = "{version}"',
        f'    supported_languages = ["en"]',
        "",
        "    # Required fields for validation",
        f"    REQUIRED_FIELDS = {field_names}",
        "",
        "    # Field zones with extraction/validation rules",
        "    FIELD_ZONES = {",
    ]

    # Add each field
    for field_name, zone_config in zones.items():
        clean = clean_zone_config(zone_config)

        lines.append(f"        '{field_name}': {{")

        # Always include coordinates first - ensure they're formatted as tuples
        y_range = clean['y_range']
        x_range = clean['x_range']
        # Convert to tuple if list, keep as tuple if already tuple
        y_tuple = tuple(y_range) if isinstance(y_range, (list, tuple)) else y_range
        x_tuple = tuple(x_range) if isinstance(x_range, (list, tuple)) else x_range
        lines.append(f"            'y_range': {y_tuple},")
        lines.append(f"            'x_range': {x_tuple},")

        # Format and format-specific keys
        if 'format' in clean:
            lines.append(f"            'format': '{clean['format']}',")

            if 'date_format' in clean:
                lines.append(f"            'date_format': '{clean['date_format']}',")
            if 'height_format' in clean:
                lines.append(f"            'height_format': '{clean['height_format']}',")
            if 'weight_format' in clean:
                lines.append(f"            'weight_format': '{clean['weight_format']}',")

        # Pattern keys (with r"" prefix for raw strings - smart quote selection)
        if 'pattern' in clean:
            # Choose quote style based on pattern content to avoid escaping issues
            pattern_value = clean['pattern']
            if '"' in pattern_value and "'" not in pattern_value:
                # Use single quotes if pattern has double quotes but no single quotes
                lines.append(f"            'pattern': r'{pattern_value}',")
            elif "'" in pattern_value and '"' not in pattern_value:
                # Use double quotes if pattern has single quotes but no double quotes
                lines.append(f'            "pattern": r"{pattern_value}",')
            elif "'" not in pattern_value and '"' not in pattern_value:
                # No quotes in pattern, use double quotes
                lines.append(f'            "pattern": r"{pattern_value}",')
            else:
                # Pattern has both types of quotes - use triple quotes
                lines.append(f'            "pattern": r"""{pattern_value}""",')
        if 'cleanup_pattern' in clean:
            cleanup_value = clean['cleanup_pattern']
            if '"' in cleanup_value and "'" not in cleanup_value:
                lines.append(f"            'cleanup_pattern': r'{cleanup_value}',")
            elif "'" in cleanup_value and '"' not in cleanup_value:
                lines.append(f'            "cleanup_pattern": r"{cleanup_value}",')
            elif "'" not in cleanup_value and '"' not in cleanup_value:
                lines.append(f'            "cleanup_pattern": r"{cleanup_value}",')
            else:
                lines.append(f'            "cleanup_pattern": r"""{cleanup_value}""",')
        if 'consensus_extract' in clean:
            consensus_value = clean['consensus_extract']
            if '"' in consensus_value and "'" not in consensus_value:
                lines.append(f"            'consensus_extract': r'{consensus_value}',")
            elif "'" in consensus_value and '"' not in consensus_value:
                lines.append(f'            "consensus_extract": r"{consensus_value}",')
            elif "'" not in consensus_value and '"' not in consensus_value:
                lines.append(f'            "consensus_extract": r"{consensus_value}",')
            else:
                lines.append(f'            "consensus_extract": r"""{consensus_value}""",')

        # Expected labels (fuzzy matching for label detection)
        if 'labels' in clean:
            labels = clean['labels']
            # Format as list of strings
            label_strings = [f"'{label}'" if '"' not in label else f'"{label}"' for label in labels]
            lines.append(f"            'labels': [{', '.join(label_strings)}],")

        # Clustering keys
        if 'cluster_by' in clean:
            lines.append(f"            'cluster_by': '{clean['cluster_by']}',")
        if 'cluster_select' in clean:
            lines.append(f"            'cluster_select': '{clean['cluster_select']}',")
        if 'cluster_tolerance' in clean:
            lines.append(f"            'cluster_tolerance': {clean['cluster_tolerance']},")

        # Tie-breaking strategy
        if 'tie_break_prefer' in clean:
            lines.append(f"            'tie_break_prefer': '{clean['tie_break_prefer']}',")

        # Boolean flags
        if 'uppercase' in clean:
            lines.append(f"            'uppercase': True,")
        if 'validate_alphabetic' in clean:
            lines.append(f"            'validate_alphabetic': True,")
        if 'allow_commas' in clean:
            lines.append(f"            'allow_commas': {clean['allow_commas']},")
        if 'allow_digits' in clean:
            lines.append(f"            'allow_digits': {clean['allow_digits']},")
        if 'strict_validation' in clean:
            lines.append(f"            'strict_validation': True,")
        if 'optional' in clean:
            lines.append(f"            'optional': True,")

        lines.append("        },")

    lines.append("    }")
    lines.append("")

    # Add get_field_schema method
    lines.append("    def get_field_schema(self) -> Dict[str, Dict[str, Any]]:")
    lines.append('        """Auto-generate schema from FIELD_ZONES"""')
    lines.append("        return {")
    lines.append("            field_name: {")
    lines.append("                'type': zone_config.get('format', 'string'),")
    lines.append("                'required': field_name in self.REQUIRED_FIELDS,")
    lines.append("                **({'pattern': zone_config['pattern']} if 'pattern' in zone_config else {})")
    lines.append("            }")
    lines.append("            for field_name, zone_config in self.FIELD_ZONES.items()")
    lines.append("        }")
    lines.append("")

    return "\n".join(lines)


def preview_zone_status(zones: Dict[str, Dict[str, Any]]) -> list:
    """
    Generate preview of zone configurations for display

    Returns list of dicts with preview information
    """
    previews = []

    for field_name, zone_config in zones.items():
        has_pattern = bool(zone_config.get('pattern'))
        has_cleanup = bool(zone_config.get('cleanup_pattern'))
        has_consensus = bool(zone_config.get('consensus_extract'))
        has_format = zone_config.get('format') and zone_config['format'] != 'string'

        # Determine status
        if has_format or (has_pattern and has_cleanup):
            status = "✅"
            message = "Fully configured"
        elif has_pattern or has_cleanup:
            status = "⚠️"
            message = "Partially configured"
        else:
            status = "❌"
            message = "No patterns set"

        preview = {
            'field_name': field_name,
            'status': status,
            'message': message,
            'x_range': zone_config['x_range'],
            'y_range': zone_config['y_range'],
            'format': zone_config.get('format', 'string'),
            'has_pattern': has_pattern,
            'has_cleanup': has_cleanup,
            'has_consensus': has_consensus,
            'pattern': zone_config.get('pattern', ''),
            'cleanup_pattern': zone_config.get('cleanup_pattern', ''),
            'consensus_extract': zone_config.get('consensus_extract', ''),
        }

        # Add format-specific info
        if zone_config.get('format') == 'date':
            preview['date_format'] = zone_config.get('date_format', 'MM.DD.YYYY')
        elif zone_config.get('format') == 'height':
            preview['height_format'] = zone_config.get('height_format', 'us')
        elif zone_config.get('format') == 'weight':
            preview['weight_format'] = zone_config.get('weight_format', 'us')

        previews.append(preview)

    return previews
